# -*- coding: utf-8 -*-
"""PokeGAN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tf1ZX9avzqkxGWobTELMf-TZHOTPFd4x
"""

import torch
import torchvision
import torch.nn as nn  # All neural network modules, nn.Linear, nn.Conv2d, BatchNorm, Loss functions
import torch.optim as optim  # For all Optimization algorithms, SGD, Adam, etc.
import torchvision.datasets as datasets  # Has standard datasets we can import in a nice way
import torchvision.transforms as transforms  # Transformations we can perform on our dataset
from torch.utils.data import (
    DataLoader,
)  # Gives easier dataset managment and creates mini batches
from torch.utils.tensorboard import SummaryWriter  # to print to tensorboard

lr = 0.0005
batch_size = 64
image_size = 64
channels_img = 3
channels_noise = 256


# For how many channels Generator and Discriminator should use
features_d = 16
features_g = 16

my_transforms = transforms.Compose(
    [
        transforms.Resize(image_size),
        transforms.ToTensor(),
        transforms.Normalize((0.5,), (0.5,)),
    ]
)

dataset= '/content/pokemon'

folder = datasets.ImageFolder(dataset,transform=my_transforms)

dataloader = DataLoader(folder,batch_size=batch_size,shuffle = True)

class Discriminator(nn.Module):
    def __init__(self, channels_img, features_d):
        super(Discriminator, self).__init__()
        self.net = nn.Sequential(
            # N x channels_img x 64 x 64
            nn.Conv2d(channels_img, features_d, kernel_size=4, stride=2, padding=1),
            nn.LeakyReLU(0.2),
            # N x features_d x 32 x 32
            nn.Conv2d(features_d, features_d * 2, kernel_size=4, stride=2, padding=1),
            nn.BatchNorm2d(features_d * 2),
            nn.LeakyReLU(0.2),
            nn.Conv2d(
                features_d * 2, features_d * 4, kernel_size=4, stride=2, padding=1
            ),
            nn.BatchNorm2d(features_d * 4),
            nn.LeakyReLU(0.2),
            nn.Conv2d(
                features_d * 4, features_d * 8, kernel_size=4, stride=2, padding=1
            ),
            nn.BatchNorm2d(features_d * 8),
            nn.LeakyReLU(0.2),
            # N x features_d*8 x 4 x 4
            nn.Conv2d(features_d * 8, 1, kernel_size=4, stride=2, padding=0),
            # N x 1 x 1 x 1
            nn.Sigmoid(),
        )

    def forward(self, x):
        return self.net(x)

class Generator(nn.Module):
    def __init__(self, channels_noise, channels_img, features_g):
        super(Generator, self).__init__()

        self.net = nn.Sequential(
            # N x channels_noise x 1 x 1
            nn.ConvTranspose2d(
                channels_noise, features_g * 16, kernel_size=4, stride=1, padding=0
            ),
            nn.BatchNorm2d(features_g * 16),
            nn.ReLU(),
            # N x features_g*16 x 4 x 4
            nn.ConvTranspose2d(
                features_g * 16, features_g * 8, kernel_size=4, stride=2, padding=1
            ),
            nn.BatchNorm2d(features_g * 8),
            nn.ReLU(),
            nn.ConvTranspose2d(
                features_g * 8, features_g * 4, kernel_size=4, stride=2, padding=1
            ),
            nn.BatchNorm2d(features_g * 4),
            nn.ReLU(),
            nn.ConvTranspose2d(
                features_g * 4, features_g * 2, kernel_size=4, stride=2, padding=1
            ),
            nn.BatchNorm2d(features_g * 2),
            nn.ReLU(),
            nn.ConvTranspose2d(
                features_g * 2, channels_img, kernel_size=4, stride=2, padding=1
            ),
            # N x channels_img x 64 x 64
            nn.Tanh(),
        )

    def forward(self, x):
        return self.net(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

netD = Discriminator(channels_img,features_d).to(device)
netG= Generator(channels_noise,channels_img,features_g).to(device)

optimizerD = optim.Adam(netD.parameters(),lr = lr, betas=(0.5,0.999))
optimizerG = optim.Adam(netG.parameters(), lr=lr, betas=(0.5, 0.999))

netG.train()
netD.train()

criterion =  nn.BCELoss()

real_label  = 1
fake_label = 0

fixed_noise = torch.randn(64,channels_noise,1,1).to(device)
writer_real = SummaryWriter(f"runs/GAN_MNIST/test_real")
writer_fake = SummaryWriter(f"runs/GAN_MNIST/test_fake")
step = 0

num_epochs= 600

for epoch in range(num_epochs):
  for batch_idx, (data,targets) in enumerate(dataloader):
    data = data.to(device)
    batch_size = data.shape[0]


    netD.zero_grad()
    label = (torch.ones(batch_size) * 0.9).to(device)
    output = netD(data).reshape(-1)
    lossD_real = criterion(output,label)
    D_x= output.mean().item()

    noise = torch.randn(batch_size,channels_noise,1,1).to(device)
    fake = netG(noise)
    label = (torch.ones(batch_size) * 0.1).to(device)
    

    output = netD(fake.detach()).reshape(-1)
    lossD_fake = criterion(output, label)

    lossD = lossD_real + lossD_fake
    lossD.backward()
    optimizerD.step()

        ### Train Generator: max log(D(G(z)))
    netG.zero_grad()
    label = torch.ones(batch_size).to(device)
    output = netD(fake).reshape(-1)
    lossG = criterion(output, label)
    lossG.backward()
    optimizerG.step()

        # Print losses ocassionally and print to tensorboard
    if batch_idx % 100 == 0: 


      step += 1
      print(
                f"Epoch [{epoch}/{num_epochs}] Batch {batch_idx}/{len(dataloader)} \
                  Loss D: {lossD:.4f}, loss G: {lossG:.4f} D(x): {D_x:.4f}"
            )

      with torch.no_grad():

        fake = netG(fixed_noise)
        img_grid_real = torchvision.utils.make_grid(data[:32], normalize=True)
        img_grid_fake = torchvision.utils.make_grid(fake[:32], normalize=True)
        writer_real.add_image(
                    "Mnist Real Images", img_grid_real, global_step=step
                )
        writer_fake.add_image(
                    "Mnist Fake Images", img_grid_fake, global_step=step
                )

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard
# %tensorboard --logdir /content/runs/GAN_MNIST

